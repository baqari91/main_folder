# lists     
l = [] #ცაარიელი სიის შექმნა
l1 = list([1,3]) # ფუნქციის გამოძახებით  სიის შექმნა
temp = [1,33,44] # ელემენტები უნდა იყოს მძიმით გამოყოფილი ერთმანეთისგან
temp1 = [1,4.4,"string", True] # სიებში შესაძლებელია ავურიოთ მონაცემები როგორებიცაა: int,float,stv,bool(true or false) და ა.შ
temp[0] # ელემენტის გამოტანა ინდექსის მიხედვით
temp[-1]  #სიის ბოლო ელემენტის გამოძახება
          # temp[6]  თუ გამოვიძახებთ ისეთ ინდექს რომელიც არ არსებობს მივიღებთ ერორს
a=[1,2]
b=["a","b"]
c = a+b # სიების გაერთიანება
d = a*3 # მივიღებთ a სიას სამჯერ გადამბულად. არ შეიძლება სიების გამრავლება ფლოატ ტიპის რიცხვებსზე (წილადებზე)
2 in c # არის თუ არა 2იანი c სიაში. პასუხი იქნება true
"G" in c # არის თუ არა g ასო c სიაში. პასუხი იქნება  false რადგან არ არის

# გამოძახება სლაისების მიხედვით. ( ჩამონათვალი)
# a[start]          საწყისი ინდექსის ჩათვლით                 default=0 დასაწყისი
# a[start:end]      ინდექსი სადამდე გვინდა ჩამონათალი        default= სიის დასასრული
# a[start:end:step] ყოველი მერამდენე ნაბიჯი გამოჩნდეს        default= 1 ნაბიჯი
a1=[0,1,2,3,4,5,6,7,8,9,]
print("a1[3::] ",a1[3::]) # ცარიელზე იგულისხმება დეფაულთად სიის დასაწყისი ანუ ნული ინდექსი,
print("a1[::2] ",a1[::2])  # ყოველი მეორე 
print("a1[::-1] ",a1[::-1]) # -1 step-ში ნისნავს სიას გამოუყვეს ბოლოდან თავში (უკუღმა)
print(a1[0:2]) 

# სიების დაკოპირება
aa = [1,2]      #| 
bb =  [2,3]     #| 
aa = bb         #|   ამ მეთოდით დაკოპირება გამოიწვევს ერთიდა იგივე ობიექტის შექმნას მეხსიერებაში     
bb[1] = 34      #|   თუ  ჩვენ შევცვლით მაგალითად b სიის მეორე ელემენტს ასევე შეიცვლება a სიაშიც
print(aa)       #|                    
print(bb)       #| 
# როგორ უნდა დავაკოპიროთ სია ისე რომ დამოუკიდებლები გახდნენ და აღარ შეიცვალონ
bbb = aa.copy()    # bbb-ში ჩამოკიპირე aa სია 
bbb.append(33)     # დაემატა ელემენტი და ამან არ იმოქმედა aa-ზე
d = aa[:]          # ჩავაკოპიროთ d-ში aa-ს სრული მნიშვნელობები. ექვივალენტია copy() ფუნქციის
d.append(44)
print(bbb)

print(d)
# სიები სიაში
xlist = [ [1,2],[6,7]]   # ორი სია მოთავსებული ერთ სიაში
xlist[0]                 # მოგვცემს პირველ სიას
xlist[0][0]              # პირველი სიის პირველი ელემენტი
# სიების შედარება
print ("[1,2] > [0,3,4,55]: ",[1,2] > [0,3,4,55]) # პირველი სია მეტია მეორეზე? პასუხი გამოვა true  რადგან შედარებისას პითონი უყურებეს მხოლოდ პირველ ელემენტს
print([1,2,3]==[1,2,3,4]) # უდრის შემთხვევაში ყველა ელემენტი უნდა უდრიდეს ერთმანეთს თორემ პასუხს მივიღებთ false




# სიების მეთოდები და ფუნქციები
#ფუნქციები
# len(x) -    გვაჩვენებს ელემენტების რაოდენობას
# max(x) -    გვაჩვენებს მაქსიმუმ ციფრს
# min(x) -    გამოაქვს მინიმუმი ციფრი
# sum(x) -    ელემენტების აჯამვა
# sorted(x) - სორტირება სიდიდის მიხედვით
# sorted(x, reverse = true) - შეტრიალებული სორტირება
# sum(x)/len(x)   ჯამი გაყოფილი ელემენტების რაოდენობაზე, მოგვცემს საშუალო არითმეტიკულს, 
x=[1,2,3,4,5,66,77,633,2,77,3]
print(sorted(x,reverse=True))
#მეთოდი
x.append(100)         # აფენდ მეთოდი არის სიაში ელემენტის დასამატებლად, განთავსდება ბოლოში
# x.clear()           # ქლიარ მეთოდი შლის ყველა ელემენტს სიიდან
x.copy()              # განხილულია ზევით
print(x.count(2)  )   # რამდენჯერ გვხვდება 2=იანი x სიაში
xx=[155,1553]
x.extend(xx)          # სიების გაერთიანება a+b მეთოდის მსგავსად.    
print(x) 
re=x.index(77)            # რომელ პოზიციაზეა 77? გამოიტანს ელემენტის ინდექს, ხოლო თუ ვერ იპოვა აბრუნებს ერორს
print(x.index(77,(re+1),101)) # პირველი არგუმენტი  რა უნდა იპოვოს, მეორე არგუმენტი ინდექსის რომელი პოზიციიდან დაიწყოს ძებნა,ხოლო მესამე არგუმენტი სადამდე მოძებნოს
x.insert(1,33444)   # მითითებულ პოზიციაზე შეგვიძლია ჩავსვათ ელემენტი.ანუ პირველი არგუმენტი არის ინდექსი ხოლო მეორე არგუმენტი არის ელემენტი რომელიც გვინდა რომ ჩავსვათ მითითებულ პოზიციაზე
x.pop() # შლის და აბრუნებს ბოლო ელემეტს სიაში
x.pop(1) # შეგიძლია მიუთითო ელემენტი რომლის წაშლაც გინდა და გამოტანა
x.remove(77) # რემოვე მეთოდი შლის ელემენტს რომელსაც მივუთითებთ. ანუ არგუმენტად უნდა ჩავწეროთ ელემენტის მნიშვნელობა რომელიც გვინდა რომ წაიშალოსხ.ხ.
x.reverse()  # სიას შემოატრიალებს და იმახსუვრებს ანუ დროებით არა სამუდამოდ შეაბრუნებს
x.reverse()  # შევატრიალოთ ისევ
x.sort()     # sort მეთოდი განსხვავდება sorted. sorted ფუქნცია ასორტირებს მაგრამ არ იმახსოვრებს. ხოლო sort მეთოდი ასორტირებს და იმახსოვრებს სამუდამოდ$